---
trigger: model_decision
description: when the developer or a workflow asks for the application to be locally deployed
---

# Local Deployment Rule (Docker Compose)
This document defines the **only allowed ways** to run a local Docker deployment, depending on intent.

There are TWO modes:
- Mode A: **Release Candidate Deployment (Pre-merge)** — deploy from a `feature/...` branch to validate what will be merged.
- Mode B: **Latest Stable Deployment (Post-merge)** — deploy strictly from `origin/main` to run the latest stable version.

This document does not define Git workflow or PR policy. Those are defined in:
- @/.agent/rules/git-conventions.md
- @/.agent/workflows/close-feature.md (or equivalent workflow file)

----------------------------------------------------------------------

## Mode A — Release Candidate Deployment (Pre-merge)

### Purpose
Validate the **release candidate** before merging:
- This deployment validates the **current feature branch state**.
- It is used inside `/close-feature` as a runtime validation step.
- If it fails, you **must not merge**.

### Deployment source
- Deployment source is the current branch:
  - `feature/<feature-slug>`
- You MUST NOT reset to `origin/main` in this mode.

### A1) Mandatory Pre-checks
1) Ensure the working directory is clean:
- `git status`

2) Confirm you are on the expected feature branch:
- `git branch --show-current`

Stop condition:
- If you are not on `feature/<feature-slug>`, STOP and switch to it.

3) Optional but recommended: ensure your feature branch is up to date with its remote:
- `git pull origin feature/<feature-slug>`

Note:
- This mode does NOT require checking PRs targeting `main`.
- This mode is intentionally pre-merge.

### A2) Build & Local Deployment with Docker Compose
1) Inspect current containers:
- `docker compose ps`

2) If coming from an inconsistent state:
- `docker compose down`

3) Rebuild and start containers:
- Standard (safe):
  - `docker compose up -d --build`
- Clean rebuild (cache/deps suspicion):
  - `docker compose build --no-cache`
  - `docker compose up -d`

### A3) Database migrations (if applicable)
Migrations must be executed after containers are running and before functional validation.

Examples:
- Alembic:
  - `docker compose exec <backend_service> alembic upgrade head`
- Django:
  - `docker compose exec <backend_service> python manage.py migrate`
- Prisma:
  - `docker compose exec <backend_service> npx prisma migrate deploy`

Stop condition:
- If migrations fail, STOP. Do NOT merge. Fix and rerun Mode A.

### A4) Smoke test (mandatory)
- `docker compose ps`
- `docker compose logs --tail=200 -f`
- Verify services are running and healthy (if healthchecks exist).
- Validate at least one core user flow relevant to the feature.

Stop condition:
- If smoke test fails, STOP. Do NOT merge. Fix and rerun Mode A.

### A5) Traceability (recommended)
Record the exact commit being validated:
- `git rev-parse --short HEAD`

Recommendation:
- Add this hash to the closure report generated by `/close-feature`.

----------------------------------------------------------------------

## Mode B — Latest Stable Deployment (Post-merge)

### Purpose
Run the **latest stable version** locally:
- This deployment validates the exact state of `origin/main`.
- This mode is used when you want to run the stable integrated version.

### Principle
- Deployment is ALWAYS performed from `main` remote (`origin/main`).
- If there are pending PRs, meaning remote `main` does not yet include the latest completed work, the developer must be notified.
- Before deploying, the developer must decide whether to merge pending PRs first.
- Deployment is local only (Docker containers).
- No cloud / remote CI/CD deployment is assumed.

### Deployment source
- Deployment source is ALWAYS: `origin/main`

### B1) Mandatory Pre-checks (Before touching Docker)

#### B1.1 Synchronize remote references
1) Ensure working directory is clean:
- `git status`

2) Fetch the latest remote state:
- `git fetch origin --prune`

#### B1.2 Detect pending PRs targeting `main` (and notify)
Goal: avoid deploying a “latest stable version” that does not include already finished but unmerged work.

Option B1.2-A — GitHub CLI (`gh`) installed (recommended)
1) Verify GitHub CLI is available:
- `gh --version`

2) List open PRs targeting `main`:
- `gh pr list --base main --state open`

If one or more PRs are found:
- Mandatory warning:
  “There are open PRs targeting `main`. Remote `main` is not fully up to date.”
- Ask explicitly:
  “Do you want to review and merge them before deployment?”

If the developer chooses to merge using `gh`:
1) Review each PR:
- `gh pr view <PR_NUMBER> --web`
- or without `--web` for terminal view

2) Check CI status (if configured):
- `gh pr checks <PR_NUMBER>`

3) Merge (preferred: squash + delete branch):
- `gh pr merge <PR_NUMBER> --squash --delete-branch`

If merging is blocked by rules/permissions:
- Proceed to Option B1.2-B (manual).

Option B1.2-B — Without GitHub CLI (manual via GitHub UI)
1) Open the repository on GitHub.
2) Go to Pull Requests.
3) Filter:
- Base: `main`
- State: Open
4) For each pending PR:
- review changes
- verify checks (if any)
- merge (preferably Squash and merge)
- delete branch if applicable

After merging PRs (by any method):
- Refresh local references:
  - `git fetch origin --prune`

#### B1.3 Ensure deployment uses EXACTLY `origin/main`
1) Checkout `main`:
- `git checkout main`

2) Hard reset local `main` to match remote:
- `git reset --hard origin/main`

This prevents deploying:
- unpushed local commits
- outdated local branches
- accidental feature-branch code

### B2) Build & Local Deployment with Docker Compose

#### B2.1 Preparation (recommended)
- `docker compose ps`
- If coming from an inconsistent state:
  - `docker compose down`

#### B2.2 Rebuild and start containers
Standard (safe):
- `docker compose up -d --build`

Clean rebuild (cache/deps suspicion):
- `docker compose build --no-cache`
- `docker compose up -d`

Note:
- Even if your compose setup mounts source code as volumes,
  stable deployments must prefer rebuilds for consistency.

#### B2.3 Smoke test (mandatory)
- `docker compose ps`
- `docker compose logs --tail=200 -f`
- Verify healthchecks show “healthy” if defined.

### B3) Database migrations (if applicable)
Migrations must be executed after containers are running and before functional validation.

Examples:
- Alembic:
  - `docker compose exec <backend_service> alembic upgrade head`
- Django:
  - `docker compose exec <backend_service> python manage.py migrate`
- Prisma:
  - `docker compose exec <backend_service> npx prisma migrate deploy`

Stop condition:
- If migrations fail, abort deployment immediately and fix before continuing.

### B4) Deployment traceability (recommended)
To know exactly what version is running:
- `git rev-parse --short HEAD`

Record:
- date/time
- commit hash
- optional deployment note

----------------------------------------------------------------------

## Global Stability Rules (Non-negotiable)

- Never confuse the two modes:
  - Mode A validates a feature branch release candidate (pre-merge).
  - Mode B deploys the stable integrated `origin/main` (post-merge).
- If Mode A fails: do NOT merge.
- If Mode B fails: fix `main` (via hotfix) before continuing.
